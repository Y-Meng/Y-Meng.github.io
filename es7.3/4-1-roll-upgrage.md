# 滚动升级
[原文](https://www.elastic.co/guide/en/elasticsearch/reference/7.3/rolling-upgrades.html)

滚动升级允许Elasticsearch集群一次升级一个节点，这样升级不会中断服务。
不支持在升级持续时间之后在同一集群中运行多个版本的Elasticsearch，因为无法将分片从升级节点复制到运行旧版本的节点。

最好在所有其他节点之后升级集群中符合主节点条件的节点。
一旦开始升级符合主节点条件的节点，它们可能会形成一个群集，旧版本的节点无法加入。
如果最后升级符合主节点条件的节点，则所有其他节点将不会运行旧版本，因此它们将能够加入群集。

支持滚动升级：

* 在次要版本之间
* 从5.6到6.8
* 从6.8到7.3.2

从6.7或更早版本直接升级到7.3.2需要完全重新启动群集。

## 升级准备
在开始升级之前仔细准备是很重要的。一旦开始将群集升级到7.3.2版，就必须完成升级。
一旦群集包含7.3.2版的节点，它可能会对其内部状态进行无法还原的更改。
如果无法完成升级，则应放弃部分升级的群集，在升级之前部署版本的空群集，并从快照还原其内容。

在开始将群集升级到7.3.2版本之前，应执行以下操作。
1. 检查弃用日志，查看是否正在使用任何弃用的功能，并相应地更新代码。
2. 检查中断更改，并对7.3.2版的代码和配置进行任何必要的更改。
3. 如果您使用任何插件，请确保每个插件都有与Elasticsearch 7.3.2版兼容的版本。
4. 在升级生产群集之前，请在隔离环境中测试升级。
5. 通过快照备份数据！

## 升级集群
为了完成到7.3.2的滚动升级：

## 1. 禁用分片分配
当你关闭节点时，分配进程会等待index.unassigned.node_left.delayed_timeout（默认为一分钟），
然后开始将该节点上的分片复制到群集中的其他节点，这可能会涉及大量I/O。
由于该节点即将重新启动，因此不必执行此I/O。通过在关闭节点之前禁用副本的分配，可以避免使时钟加速：
```text
PUT _cluster/settings
{
  "persistent": {
    "cluster.routing.allocation.enable": "primaries"
  }
}
```

## 2. 停止非必需索引，并执行同步刷新。（可选）
虽然可以在升级过程中继续索引，但如果临时停止非必需索引并执行同步刷新，碎片恢复速度要快得多。
```text
POST _flush/synced
```
执行同步刷新时，请检查响应以确保没有失败。
在响应主体中列出了由于挂起的索引操作而失败的同步刷新操作，尽管请求本身仍然返回200 OK状态。
如果失败，请重新发出请求。

## 3. 暂时停止与活动机器学习作业和数据源关联的任务。（可选）
如果机器学习索引是在6.x之前创建的，则必须重新索引索引。
如果您的机器学习索引是在6.x中创建的，则可以进行以下操作：
* 让您的机器学习作业在升级期间运行。关闭机器学习节点时，其作业会自动移动到另一个节点并还原模型状态。
此选项允许您的作业在升级期间继续运行，但会增加群集的负载。
* 暂时停止与机器学习作业和数据源关联的任务，并使用设置升级模式API阻止打开新作业：
```text
POST _ml/set_upgrade_mode?enabled=true
```
禁用升级模式时，作业将使用自动保存的最后一个模型状态继续。
此选项避免了在升级期间管理活动作业的开销，并且比显式停止数据馈送和关闭作业更快。

* 停止所有数据源并关闭所有作业。此选项保存关闭时的模型状态。升级后重新打开作业时，它们使用完全相同的模型。
    但是，保存最新的模型状态比使用升级模式需要更长的时间，特别是当您有很多作业或具有较大模型状态的作业时。

## 4. 关闭一个节点
通过systemd方式运行的关闭命令：
```bash
sudo systemctl stop elasticsearch.service
```
通过sysV运行的关闭命令
```bash
sudo -i service elasticsearch stop
```
通过守护进程启动的关闭命令
```bash
kill $(cat pid)
```

## 5. 升级关闭的节点

使用Debian或RPM包升级：
* 使用rpm或dpkg安装新软件包。所有文件都安装在操作系统的适当位置，并且不会覆盖Elasticsearch配置文件。

使用zip或tar压缩包升级：
a. 将zip或tarball解压缩到新目录。如果不使用外部配置和数据目录，这一点非常重要。
b. 设置ES_PATH_CONF环境变量以指定外部配置目录和jvm.options文件的位置。如果不使用外部配置目录，请将旧配置复制到新安装。
c. 在config/elasticsearch.yml中设置path.data以指向外部数据目录。如果不使用外部数据目录，请将旧数据目录复制到新安装。
d. 在config/elasticsearch.yml中设置path.logs以指向要存储日志的位置。如果未指定此设置，则日志将存储在提取存档文件的目录中。

注意：
> 如果使用监视功能，请在升级Elasticsearch时重新使用数据目录。监视通过使用存储在数据目录中的持久UUID来标识唯一的Elasticsearch节点。

> 提取zip或tarball包时，elasticsearch-n.n.n目录包含elasticsearch config、data和logs目录。
我们建议将这些目录移出Elasticsearch目录，以便在升级Elasticsearch时不可能删除它们。
要指定新位置，请使用ES_PATH_CONF环境变量和path.data和path.logs设置。
有关更多信息，请参阅重要的Elasticsearch配置。

> Debian和RPM包将这些目录放在每个操作系统的适当位置。在生产中，我们建议使用deb或rpm包安装。

> 执行滚动升级时，应保持cluster.initial_master_nodes未设置。每个升级的节点都加入现有的集群，因此不需要集群自举。

## 6.升级插件
使用elasticsearch插件脚本安装每个已安装的elasticsearch插件的升级版本。升级节点时必须升级所有插件。

## 7.域设置
如果使用Elasticsearch安全功能定义领域，请验证您的领域设置是最新的。
领域设置的格式在7.0版中发生了更改，特别是领域类型的位置发生了更改。请参见领域设置。

## 8.启动升级节点
启动新升级的节点，并通过检查日志文件或提交_cat/nodes请求来确认它加入群集：
```bash
GET _cat/nodes
```

## 9.重新启用分片分配
节点加入群集后，删除cluster.routing.allocation.enable设置以启用碎片分配并开始使用节点：
```text
PUT _cluster/settings
{
  "persistent": {
    "cluster.routing.allocation.enable": null
  }
}
```

## 10.等待节点恢复
在升级下一个节点之前，请等待群集完成碎片分配。您可以通过提-cat/health请求来检查进度：
```text
GET _cat/health?v
```
等待状态列从黄色切换到绿色。一旦节点为绿色，所有主碎片和副本碎片都已分配。

> 在滚动升级期间，分配给运行新版本的节点的主碎片不能将其副本分配给具有旧版本的节点。新版本可能具有旧版本无法理解的不同数据格式。

> 如果无法将副本碎片分配给另一个节点（群集中只有一个已升级的节点），则副本碎片将保持未分配状态，并且状态将保持为黄色。

> 在这种情况下，一旦没有初始化或重新定位碎片，就可以继续（检查init和relo列）。

> 一旦另一个节点升级，就可以分配副本，状态将变为绿色。

未同步刷新的碎片可能需要更长时间才能恢复。您可以通过提交一个cat/recovery请求来监视单个碎片的恢复状态：
```bash
GET _cat/recovery
```

如果停止索引，恢复完成后恢复索引是安全的。

## 11.重复上边操作
当节点已恢复且群集稳定时，对需要更新的每个节点重复这些步骤。

## 12.重启机器学习任务
如果暂时停止与机器学习作业关联的任务，请使用设置升级模式API将其返回到活动状态：
```bash
POST _ml/set_upgrade_mode?enabled=false
```
如果在升级之前关闭了所有机器学习作业，请打开作业并从Kibana启动数据源，或使用打开的作业启动数据源API。

> 在滚动升级期间，群集继续正常运行。但是，在升级群集中的所有节点之前，任何新功能都将被禁用或以向后兼容模式运行。
一旦升级完成并且所有节点都在运行新版本，新功能就可以运行。一旦发生这种情况，就没有办法返回到向后兼容模式。
运行以前主要版本的节点将不允许加入完全更新的群集。

> 如果在升级过程中出现网络故障，将所有剩余的旧节点与群集隔离，则必须使旧节点脱机并进行升级，以使它们能够加入群集。

> 如果在升级过程中同时停止一半或更多符合主节点条件的节点，则群集将不可用，这意味着升级不再是滚动升级。
如果发生这种情况，您应该升级并重新启动所有停止的符合主节点条件的节点，以允许群集再次形成，就像执行完全群集重新启动升级一样。
可能还需要升级所有剩余的旧节点，然后才能在重新形成群集后加入群集。